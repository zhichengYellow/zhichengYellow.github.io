<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>苍穹外卖支付mock</title>
    <link href="/2025/11/28/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%94%AF%E4%BB%98mock/"/>
    <url>/2025/11/28/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%94%AF%E4%BB%98mock/</url>
    
    <content type="html"><![CDATA[<p>苍穹外卖-微信支付功能解决，最小侵入改造微信支付：mock-mode 让退单&#x2F;拒单照常可用</p><p>前言<br>在开发或演示苍穹外卖项目时，微信支付环节常常成为效率瓶颈 —— 需配置真实商户号、证书、私钥，还得模拟支付回调，尤其测试退单、拒单等涉及退款的场景时，频繁调用微信 sandbox 环境或真实接口不仅麻烦，还可能产生不必要的测试成本。</p><p>本文介绍一种最小侵入式改造方案：通过新增mock-mode开关，实现 “支付 &#x2F; 退款流程短路”，开发 &#x2F; 演示时无需依赖微信三方接口，订单状态仍能正常流转，同时保留真实支付链路，生产环境一键切回。改造仅涉及 3 类核心文件，无业务逻辑重写，兼顾灵活性与安全性。</p><p>一、改造核心思路<br>改造的核心是 <strong>“开关控制分支，不破坏原有逻辑”</strong>，整体流程如下：</p><ul><li>新增配置开关：在微信支付配置类中添加<code>mockMode</code>字段，控制是否启用模拟模式；</li><li>工具类短路改造：修改支付 &#x2F; 退款工具类，若开启<code>mockMode</code>，直接返回模拟成功结果，跳过真实 HTTP 调用；</li><li>业务层适配：订单支付业务逻辑中，根据开关分支 —— mock 模式下直接更新订单状态，真实模式走原支付流程；</li><li>环境配置隔离：开发 &#x2F; 演示环境开启 mock，生产环境关闭，敏感配置不泄露。</li></ul><p>二、具体改造步骤（附完整代码）<br>2.1 第一步：新增 mock-mode 配置开关<br>在微信支付配置类中添加<code>mockMode</code>字段，默认关闭（避免开发漏改导致生产问题）。</p><p>文件路径：<code>sky-common/src/main/java/com/sky/properties/WeChatProperties.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.properties;<br> <br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br> <br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;sky.wechat&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatProperties</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> String appid;<br>    <span class="hljs-keyword">private</span> String secret;<br>    <span class="hljs-keyword">private</span> String mchid;<br>    <span class="hljs-keyword">private</span> String mchSerialNo;<br>    <span class="hljs-keyword">private</span> String privateKeyFilePath;<br>    <span class="hljs-keyword">private</span> String apiV3Key;<br>    <span class="hljs-keyword">private</span> String weChatPayCertFilePath;<br>    <span class="hljs-keyword">private</span> String notifyUrl;<br>    <span class="hljs-keyword">private</span> String refundNotifyUrl;<br> <br>    <span class="hljs-comment">// 模拟支付/退款开关</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">mockMode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一键获取完整项目代码</p><p>2.2 第二步：支付 &#x2F; 退款工具类短路改造<br>修改 <code>WeChatPayUtil</code>，在 <code>pay()</code>（下单）和 <code>refund()</code>（退款）方法首行添加开关判断 —— 开启 mock 时直接返回模拟结果，不执行真实微信接口调用。</p><p>文件路径：<code>sky-common/src/main/java/com/sky/utils/WeChatPayUtil.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">pay</span><span class="hljs-params">(String orderNum, BigDecimal total, String description, String openid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(weChatProperties.getMockMode())) &#123;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">timeStamp</span> <span class="hljs-operator">=</span> String.valueOf(System.currentTimeMillis() / <span class="hljs-number">1000</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nonceStr</span> <span class="hljs-operator">=</span> RandomStringUtils.randomNumeric(<span class="hljs-number">32</span>);<br>        jo.put(<span class="hljs-string">&quot;timeStamp&quot;</span>, timeStamp);<br>        jo.put(<span class="hljs-string">&quot;nonceStr&quot;</span>, nonceStr);<br>        jo.put(<span class="hljs-string">&quot;package&quot;</span>, <span class="hljs-string">&quot;prepay_id=mock_prepay_id&quot;</span>);<br>        jo.put(<span class="hljs-string">&quot;signType&quot;</span>, <span class="hljs-string">&quot;RSA&quot;</span>);<br>        jo.put(<span class="hljs-string">&quot;paySign&quot;</span>, <span class="hljs-string">&quot;mock-sign&quot;</span>);<br>        <span class="hljs-keyword">return</span> jo;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">bodyAsString</span> <span class="hljs-operator">=</span> jsapi(orderNum, total, description, openid);<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(bodyAsString);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">prepayId</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;prepay_id&quot;</span>);<br>    <span class="hljs-keyword">if</span> (prepayId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">timeStamp</span> <span class="hljs-operator">=</span> String.valueOf(System.currentTimeMillis() / <span class="hljs-number">1000</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nonceStr</span> <span class="hljs-operator">=</span> RandomStringUtils.randomNumeric(<span class="hljs-number">32</span>);<br>        ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(weChatProperties.getAppid());<br>        list.add(timeStamp);<br>        list.add(nonceStr);<br>        list.add(<span class="hljs-string">&quot;prepay_id=&quot;</span> + prepayId);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (Object o : list) stringBuilder.append(o).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">signMessage</span> <span class="hljs-operator">=</span> stringBuilder.toString();<br>        <span class="hljs-type">byte</span>[] message = signMessage.getBytes();<br> <br>        <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> Signature.getInstance(<span class="hljs-string">&quot;SHA256withRSA&quot;</span>);<br>        signature.initSign(PemUtil.loadPrivateKey(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(weChatProperties.getPrivateKeyFilePath()))));<br>        signature.update(message);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">packageSign</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(signature.sign());<br> <br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        jo.put(<span class="hljs-string">&quot;timeStamp&quot;</span>, timeStamp);<br>        jo.put(<span class="hljs-string">&quot;nonceStr&quot;</span>, nonceStr);<br>        jo.put(<span class="hljs-string">&quot;package&quot;</span>, <span class="hljs-string">&quot;prepay_id=&quot;</span> + prepayId);<br>        jo.put(<span class="hljs-string">&quot;signType&quot;</span>, <span class="hljs-string">&quot;RSA&quot;</span>);<br>        jo.put(<span class="hljs-string">&quot;paySign&quot;</span>, packageSign);<br>        <span class="hljs-keyword">return</span> jo;<br>    &#125;<br>    <span class="hljs-keyword">return</span> jsonObject;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">refund</span><span class="hljs-params">(String outTradeNo, String outRefundNo, BigDecimal refund, BigDecimal total)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(weChatProperties.getMockMode())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;\&quot;status\&quot;:\&quot;SUCCESS\&quot;,\&quot;channel\&quot;:\&quot;mock\&quot;&#125;&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    jsonObject.put(<span class="hljs-string">&quot;out_trade_no&quot;</span>, outTradeNo);<br>    jsonObject.put(<span class="hljs-string">&quot;out_refund_no&quot;</span>, outRefundNo);<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    amount.put(<span class="hljs-string">&quot;refund&quot;</span>, refund.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">100</span>)).setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).intValue());<br>    amount.put(<span class="hljs-string">&quot;total&quot;</span>, total.multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">100</span>)).setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP).intValue());<br>    amount.put(<span class="hljs-string">&quot;currency&quot;</span>, <span class="hljs-string">&quot;CNY&quot;</span>);<br>    jsonObject.put(<span class="hljs-string">&quot;amount&quot;</span>, amount);<br>    jsonObject.put(<span class="hljs-string">&quot;notify_url&quot;</span>, weChatProperties.getRefundNotifyUrl());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> jsonObject.toJSONString();<br>    <span class="hljs-keyword">return</span> post(REFUNDS, body);<br>&#125;<br></code></pre></td></tr></table></figure><p>一键获取完整项目代码</p><p>2.3 第三步：订单业务层适配开关<br>在订单支付业务（<code>OrderServiceImpl</code>）中，注入 <code>WeChatProperties</code>，根据 <code>mockMode</code> 分支处理：</p><ul><li>mock 关闭：走原流程（调用 <code>WeChatPayUtil.pay()</code>，获取真实支付参数）；</li><li>mock 开启：直接更新订单状态为 “已支付 &#x2F; 待接单”，并构造与工具类一致的模拟支付 VO。</li></ul><p>文件路径：<code>sky-server/src/main/java/com/sky/service/impl/OrderServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sky.properties.WeChatProperties;<br> <br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> WeChatProperties weChatProperties;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> OrderPaymentVO <span class="hljs-title function_">payment</span><span class="hljs-params">(OrdersPaymentDTO ordersPaymentDTO)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getById(userId);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">mock</span> <span class="hljs-operator">=</span> Boolean.TRUE.equals(weChatProperties.getMockMode());<br> <br>    <span class="hljs-keyword">if</span> (!mock) &#123;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> weChatPayUtil.pay(<br>                ordersPaymentDTO.getOrderNumber(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>),<br>                <span class="hljs-string">&quot;苍穹外卖订单&quot;</span>,<br>                user.getOpenid()<br>        );<br>        <span class="hljs-keyword">if</span> (jsonObject.getString(<span class="hljs-string">&quot;code&quot;</span>) != <span class="hljs-literal">null</span> &amp;&amp; jsonObject.getString(<span class="hljs-string">&quot;code&quot;</span>).equals(<span class="hljs-string">&quot;ORDERPAID&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;该订单已支付&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">OrderPaymentVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> jsonObject.toJavaObject(OrderPaymentVO.class);<br>        vo.setPackageStr(jsonObject.getString(<span class="hljs-string">&quot;package&quot;</span>));<br>        <span class="hljs-keyword">return</span> vo;<br>    &#125;<br> <br>    <span class="hljs-comment">// 模拟支付：直接置为已支付、待接单</span><br>    orderMapper.updateStatus(Orders.TO_BE_CONFIRMED, Orders.PAID, LocalDateTime.now(), ordersPaymentDTO.getOrderNumber());<br> <br>    <span class="hljs-type">OrderPaymentVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPaymentVO</span>();<br>    vo.setNonceStr(<span class="hljs-string">&quot;mock-nonce&quot;</span>);<br>    vo.setTimeStamp(String.valueOf(System.currentTimeMillis() / <span class="hljs-number">1000</span>));<br>    vo.setSignType(<span class="hljs-string">&quot;RSA&quot;</span>);<br>    vo.setPackageStr(<span class="hljs-string">&quot;prepay_id=mock_prepay_id&quot;</span>);<br>    vo.setPaySign(<span class="hljs-string">&quot;mock-sign&quot;</span>);<br>    <span class="hljs-keyword">return</span> vo;<br>&#125;<br></code></pre></td></tr></table></figure><p>一键获取完整项目代码</p><p>2.4 第四步：环境配置（开发 &#x2F; 生产隔离）<br>在开发环境配置文件中开启 <code>mock-mode</code>，生产环境保持关闭（并配置真实商户信息），避免敏感信息泄露。</p><p>文件路径：<code>sky-server/src/main/resources/application-dev.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">wechat:</span><br>    <span class="hljs-comment"># 开发环境：开启mock模式，无需配置真实商户信息</span><br>    <span class="hljs-attr">mock-mode:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 真实配置（开发环境可注释，生产环境需填写）</span><br>    <span class="hljs-comment"># mchid: 1234567890</span><br>    <span class="hljs-comment"># private-key: 你的私钥</span><br>    <span class="hljs-comment"># certificate: 证书路径</span><br>    <span class="hljs-comment"># notify-url: https://你的域名/wechat/pay/notify</span><br></code></pre></td></tr></table></figure><p>一键获取完整项目代码<br>生产环境配置参考（<code>application-prod.yml</code>）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">wechat:</span><br>    <span class="hljs-comment"># 生产环境：强制关闭mock，使用真实支付</span><br>    <span class="hljs-attr">mock-mode:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 真实商户配置（需替换为自己的信息，且不提交到代码仓库）</span><br>    <span class="hljs-attr">mchid:</span> <span class="hljs-string">你的真实商户号</span><br>    <span class="hljs-attr">private-key:</span> <span class="hljs-string">classpath:cert/你的私钥.pem</span><br>    <span class="hljs-attr">certificate:</span> <span class="hljs-string">classpath:cert/你的证书.p12</span><br>    <span class="hljs-attr">notify-url:</span> <span class="hljs-string">https://你的生产域名/wechat/pay/notify</span><br></code></pre></td></tr></table></figure><p>一键获取完整项目代码<br>三、改造效果验证<br>改造后，无需依赖微信接口即可完成支付、退单、拒单全流程测试，验证步骤如下：</p><p>3.1 验证 “模拟支付” 流程</p><ul><li>下单：调用用户端下单接口，生成待支付订单（status&#x3D;1，pay_status&#x3D;0）；</li><li>发起支付：调用 <code>PUT /user/order/payment</code> 接口，传入订单号；</li><li>查库验证：查询 <code>orders</code> 表，确认订单状态更新为：<ul><li>status&#x3D;2（待接单）</li><li>pay_status&#x3D;1（已支付）</li><li>checkout_time（支付时间）非空。</li></ul></li></ul><p>3.2 验证 “模拟退款” 流程</p><ul><li>发起退单：用户取消订单（或商家拒单），触发退款逻辑；</li><li>日志验证：查看控制台日志，应出现类似模拟退款成功，订单号：xxx，退款单号：xxx的信息（可在 <code>WeChatPayUtil.refund()</code> 的 mock 分支中添加日志）；</li><li>业务验证：退款后订单状态正常流转（如 “已取消”），无报错。</li></ul><p>3.3 验证 “真实支付” 切换</p><ul><li>将 <code>application-dev.yml</code> 中 <code>mock-mode</code> 改为 <code>false</code>，并配置真实商户信息；</li><li>重复 3.1 步骤，此时会调用真实微信支付接口，返回真实 <code>prepay_id</code>，需用微信扫码或小程序调起支付；</li><li>支付成功后，微信会回调 <code>notify-url</code>，订单状态正常更新（与改造前一致）。</li></ul><p>四、注意事项（避坑指南）</p><ul><li>敏感配置不提交仓库：商户号、私钥、证书等敏感信息，需通过环境变量或配置中心注入，禁止硬编码或提交到 Git 仓库（可在 <code>.gitignore</code> 中添加 <code>cert/</code> 目录，忽略证书文件）。</li><li>mock 仅用于开发 &#x2F; 演示：生产环境必须将 <code>mock-mode</code> 设为 <code>false</code>，并完成微信支付的全链路配置（包括回调接口的 SSL 证书、商户号权限开通等），否则会导致真实支付失败。</li><li>模拟参数格式与真实一致：mock 返回的 <code>timeStamp</code>（秒级，非毫秒级）、<code>package</code>（前缀 <code>prepay_id=</code>）、<code>signType</code>（RSA）等参数格式，必须与微信真实返回一致，避免前端调起支付时解析报错。</li><li>日志区分 mock 与真实：在 <code>WeChatPayUtil</code> 的 mock 分支中添加明确日志（如 <code>log.info(&quot;模拟支付成功，订单号：&#123;&#125;&quot;, orderNumber)</code>），便于问题排查时区分 “模拟” 和 “真实” 流程。</li></ul><p>五、改造总结<br>本次改造是 <strong>“最小侵入式”</strong> 的典范 —— 仅修改 3 类文件，新增 1 个开关，不破坏原有业务逻辑，实现了：</p><ul><li>开发效率提升：无需配置微信 sandbox 环境，1 分钟完成支付 &#x2F; 退款测试；</li><li>演示灵活性：对外演示时，无需真实支付，直接展示全流程；</li><li>生产安全性：mock 与真实流程隔离，生产环境一键切回，无风险。</li></ul><p>若后续需要扩展（如支持支付宝 mock），可参考此思路，在对应工具类中添加开关分支，保持设计一致性。</p><h2 id="————————————————版权声明：本文为CSDN博主「NEFUyellow386」的原创文章，遵循CC-4-0-BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https-blog-csdn-net-2401-87905604-article-details-150648202"><a href="#————————————————版权声明：本文为CSDN博主「NEFUyellow386」的原创文章，遵循CC-4-0-BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https-blog-csdn-net-2401-87905604-article-details-150648202" class="headerlink" title="————————————————版权声明：本文为CSDN博主「NEFUyellow386」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/2401_87905604/article/details/150648202"></a>————————————————<br>版权声明：本文为CSDN博主「NEFUyellow386」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/2401_87905604/article/details/150648202">https://blog.csdn.net/2401_87905604/article/details/150648202</a></h2><h2 id="title-苍穹外卖支付mockdate-2025-11-28-20-42-20tags-Java-spring-boot-mockcategory-Java-spring-boot"><a href="#title-苍穹外卖支付mockdate-2025-11-28-20-42-20tags-Java-spring-boot-mockcategory-Java-spring-boot" class="headerlink" title="title: 苍穹外卖支付mockdate: 2025-11-28 20:42:20tags:  - Java  - spring boot  - mockcategory:  - Java  - spring boot"></a>title: 苍穹外卖支付mock<br>date: 2025-11-28 20:42:20<br>tags:<br>  - Java<br>  - spring boot<br>  - mock<br>category:<br>  - Java<br>  - spring boot</h2><p>苍穹外卖-微信支付功能解决，最小侵入改造微信支付：mock-mode 让退单&#x2F;拒单照常可用</p><p>前言<br>在开发或演示苍穹外卖项目时，微信支付环节常常成为效率瓶颈 —— 需配置真实商户号、证书、私钥，还得模拟支付回调，尤其测试退单、拒单等涉及退款的场景时，频繁调用微信 sandbox 环境或真实接口不仅麻烦，还可能产生不必要的测试成本。</p><p>本文介绍一种最小侵入式改造方案：通过新增mock-mode开关，实现 “支付 &#x2F; 退款流程短路”，开发 &#x2F; 演示时无需依赖微信三方接口，订单状态仍能正常流转，同时保留真实支付链路，生产环境一键切回。改造仅涉及 3 类核心文件，无业务逻辑重写，兼顾灵活性与安全性。</p><p>一、改造核心思路<br>改造的核心是 <strong>“开关控制分支，不破坏原有逻辑”</strong>，整体流程如下：</p><p>新增配置开关：在微信支付配置类中添加mockMode字段，控制是否启用模拟模式；<br>工具类短路改造：修改支付 &#x2F; 退款工具类，若开启mockMode，直接返回模拟成功结果，跳过真实 HTTP 调用；<br>业务层适配：订单支付业务逻辑中，根据开关分支 ——mock 模式下直接更新订单状态，真实模式走原支付流程；<br>环境配置隔离：开发 &#x2F; 演示环境开启 mock，生产环境关闭，敏感配置不泄露。<br>二、具体改造步骤（附完整代码）<br>2.1 第一步：新增 mock-mode 配置开关<br>在微信支付配置类中添加mockMode字段，默认关闭（避免开发漏改导致生产问题）。</p><p>文件路径：sky-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;sky&#x2F;properties&#x2F;WeChatProperties.java</p><p>java</p><p>运行</p><p>package com.sky.properties;</p><p>import lombok.Data;<br>import org.springframework.boot.context.properties.ConfigurationProperties;<br>import org.springframework.stereotype.Component;</p><p>@Component<br>@ConfigurationProperties(prefix &#x3D; “sky.wechat”)<br>@Data<br>public class WeChatProperties {</p><pre><code class="hljs">private String appid;private String secret;private String mchid;private String mchSerialNo;private String privateKeyFilePath;private String apiV3Key;private String weChatPayCertFilePath;private String notifyUrl;private String refundNotifyUrl;// 模拟支付/退款开关private Boolean mockMode = false;</code></pre><p>}<br>一键获取完整项目代码<br>java</p><p>2.2 第二步：支付 &#x2F; 退款工具类短路改造<br>修改WeChatPayUtil，在pay()（下单）和refund()（退款）方法首行添加开关判断 —— 开启 mock 时直接返回模拟结果，不执行真实微信接口调用。</p><p>文件路径：sky-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;sky&#x2F;utils&#x2F;WeChatPayUtil.java</p><p>java</p><p>运行</p><p>public JSONObject pay(String orderNum, BigDecimal total, String description, String openid) throws Exception {<br>    if (Boolean.TRUE.equals(weChatProperties.getMockMode()))) {<br>        JSONObject jo &#x3D; new JSONObject();<br>        String timeStamp &#x3D; String.valueOf(System.currentTimeMillis() &#x2F; 1000);<br>        String nonceStr &#x3D; RandomStringUtils.randomNumeric(32);<br>        jo.put(“timeStamp”, timeStamp);<br>        jo.put(“nonceStr”, nonceStr);<br>        jo.put(“package”, “prepay_id&#x3D;mock_prepay_id”);<br>        jo.put(“signType”, “RSA”);<br>        jo.put(“paySign”, “mock-sign”);<br>        return jo;<br>    }<br>    String bodyAsString &#x3D; jsapi(orderNum, total, description, openid);<br>    JSONObject jsonObject &#x3D; JSON.parseObject(bodyAsString);<br>    String prepayId &#x3D; jsonObject.getString(“prepay_id”);<br>    if (prepayId !&#x3D; null) {<br>        String timeStamp &#x3D; String.valueOf(System.currentTimeMillis() &#x2F; 1000);<br>        String nonceStr &#x3D; RandomStringUtils.randomNumeric(32);<br>        ArrayList<Object> list &#x3D; new ArrayList&lt;&gt;();<br>        list.add(weChatProperties.getAppid());<br>        list.add(timeStamp);<br>        list.add(nonceStr);<br>        list.add(“prepay_id&#x3D;” + prepayId);<br>        StringBuilder stringBuilder &#x3D; new StringBuilder();<br>        for (Object o : list) stringBuilder.append(o).append(“\n”);<br>        String signMessage &#x3D; stringBuilder.toString();<br>        byte[] message &#x3D; signMessage.getBytes();</p><pre><code class="hljs">    Signature signature = Signature.getInstance(&quot;SHA256withRSA&quot;);    signature.initSign(PemUtil.loadPrivateKey(new FileInputStream(new File(weChatProperties.getPrivateKeyFilePath()))));    signature.update(message);    String packageSign = Base64.getEncoder().encodeToString(signature.sign());    JSONObject jo = new JSONObject();    jo.put(&quot;timeStamp&quot;, timeStamp);    jo.put(&quot;nonceStr&quot;, nonceStr);    jo.put(&quot;package&quot;, &quot;prepay_id=&quot; + prepayId);    jo.put(&quot;signType&quot;, &quot;RSA&quot;);    jo.put(&quot;paySign&quot;, packageSign);    return jo;&#125;return jsonObject;</code></pre><p>}</p><p>public String refund(String outTradeNo, String outRefundNo, BigDecimal refund, BigDecimal total) throws Exception {<br>    if (Boolean.TRUE.equals(weChatProperties.getMockMode())) {<br>        return “{&quot;status&quot;:&quot;SUCCESS&quot;,&quot;channel&quot;:&quot;mock&quot;}”;<br>    }<br>    JSONObject jsonObject &#x3D; new JSONObject();<br>    jsonObject.put(“out_trade_no”, outTradeNo);<br>    jsonObject.put(“out_refund_no”, outRefundNo);<br>    JSONObject amount &#x3D; new JSONObject();<br>    amount.put(“refund”, refund.multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue());<br>    amount.put(“total”, total.multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue());<br>    amount.put(“currency”, “CNY”);<br>    jsonObject.put(“amount”, amount);<br>    jsonObject.put(“notify_url”, weChatProperties.getRefundNotifyUrl());<br>    String body &#x3D; jsonObject.toJSONString();<br>    return post(REFUNDS, body);<br>}</p><p>一键获取完整项目代码<br>java</p><p>2.3 第三步：订单业务层适配开关<br>在订单支付业务（OrderServiceImpl）中，注入WeChatProperties，根据mockMode分支处理：</p><p>mock 关闭：走原流程（调用WeChatPayUtil.pay()，获取真实支付参数）；<br>mock 开启：直接更新订单状态为 “已支付 &#x2F; 待接单”，并构造与工具类一致的模拟支付 VO。<br>文件路径：sky-server&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;sky&#x2F;service&#x2F;impl&#x2F;OrderServiceImpl.java</p><p>java</p><p>运行</p><p>import com.sky.properties.WeChatProperties;</p><p>@Autowired<br>private WeChatProperties weChatProperties;</p><p>@Override<br>public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception{<br>    Long userId &#x3D; BaseContext.getCurrentId();<br>    User user &#x3D; userMapper.getById(userId);<br>    boolean mock &#x3D; Boolean.TRUE.equals(weChatProperties.getMockMode());</p><pre><code class="hljs">if (!mock) &#123;    JSONObject jsonObject = weChatPayUtil.pay(            ordersPaymentDTO.getOrderNumber(),            new BigDecimal(0.01),            &quot;苍穹外卖订单&quot;,            user.getOpenid()    );    if (jsonObject.getString(&quot;code&quot;) != null &amp;&amp; jsonObject.getString(&quot;code&quot;).equals(&quot;ORDERPAID&quot;)) &#123;        throw new OrderBusinessException(&quot;该订单已支付&quot;);    &#125;    OrderPaymentVO vo = jsonObject.toJavaObject(OrderPaymentVO.class);    vo.setPackageStr(jsonObject.getString(&quot;package&quot;));    return vo;&#125;// 模拟支付：直接置为已支付、待接单orderMapper.updateStatus(Orders.TO_BE_CONFIRMED, Orders.PAID, LocalDateTime.now(), ordersPaymentDTO.getOrderNumber());OrderPaymentVO vo = new OrderPaymentVO();vo.setNonceStr(&quot;mock-nonce&quot;);vo.setTimeStamp(String.valueOf(System.currentTimeMillis() / 1000));vo.setSignType(&quot;RSA&quot;);vo.setPackageStr(&quot;prepay_id=mock_prepay_id&quot;);vo.setPaySign(&quot;mock-sign&quot;);return vo;</code></pre><p>}<br>一键获取完整项目代码<br>java</p><p>2.4 第四步：环境配置（开发 &#x2F; 生产隔离）<br>在开发环境配置文件中开启mock-mode，生产环境保持关闭（并配置真实商户信息），避免敏感信息泄露。</p><p>文件路径：sky-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;application-dev.yml</p><p>yaml</p><p>sky:<br>  wechat:<br>    # 开发环境：开启mock模式，无需配置真实商户信息<br>    mock-mode: true<br>    # 真实配置（开发环境可注释，生产环境需填写）<br>    # mchid: 1234567890<br>    # private-key: 你的私钥<br>    # certificate: 证书路径<br>    # notify-url: https:&#x2F;&#x2F;你的域名&#x2F;wechat&#x2F;pay&#x2F;notify<br>一键获取完整项目代码<br>生产环境配置参考（application-prod.yml）：</p><p>yaml</p><p>sky:<br>  wechat:<br>    # 生产环境：强制关闭mock，使用真实支付<br>    mock-mode: false<br>    # 真实商户配置（需替换为自己的信息，且不提交到代码仓库）<br>    mchid: 你的真实商户号<br>    private-key: classpath:cert&#x2F;你的私钥.pem<br>    certificate: classpath:cert&#x2F;你的证书.p12<br>    notify-url: https:&#x2F;&#x2F;你的生产域名&#x2F;wechat&#x2F;pay&#x2F;notify<br>一键获取完整项目代码<br>三、改造效果验证<br>改造后，无需依赖微信接口即可完成支付、退单、拒单全流程测试，验证步骤如下：</p><p>3.1 验证 “模拟支付” 流程<br>下单：调用用户端下单接口，生成待支付订单（status&#x3D;1，pay_status&#x3D;0）；<br>发起支付：调用PUT &#x2F;user&#x2F;order&#x2F;payment接口，传入订单号；<br>查库验证：查询orders表，确认订单状态更新为：<br>status&#x3D;2（待接单）<br>pay_status&#x3D;1（已支付）<br>checkout_time（支付时间）非空。<br>3.2 验证 “模拟退款” 流程<br>发起退单：用户取消订单（或商家拒单），触发退款逻辑；<br>日志验证：查看控制台日志，应出现类似模拟退款成功，订单号：xxx，退款单号：xxx的信息（可在WeChatPayUtil.refund()的 mock 分支中添加日志）；<br>业务验证：退款后订单状态正常流转（如 “已取消”），无报错。<br>3.3 验证 “真实支付” 切换<br>将application-dev.yml中mock-mode改为false，并配置真实商户信息；<br>重复 3.1 步骤，此时会调用真实微信支付接口，返回真实prepay_id，需用微信扫码或小程序调起支付；<br>支付成功后，微信会回调notify-url，订单状态正常更新（与改造前一致）。<br>四、注意事项（避坑指南）<br>敏感配置不提交仓库<br>商户号、私钥、证书等敏感信息，需通过环境变量或配置中心注入，禁止硬编码或提交到 Git 仓库（可在.gitignore中添加cert&#x2F;目录，忽略证书文件）。</p><p>mock 仅用于开发 &#x2F; 演示<br>生产环境必须将mock-mode设为false，并完成微信支付的全链路配置（包括回调接口的 SSL 证书、商户号权限开通等），否则会导致真实支付失败。</p><p>模拟参数格式与真实一致<br>mock 返回的timeStamp（秒级，非毫秒级）、package（前缀prepay_id&#x3D;）、signType（RSA）等参数格式，必须与微信真实返回一致，避免前端调起支付时解析报错。</p><p>日志区分 mock 与真实<br>在WeChatPayUtil的 mock 分支中添加明确日志（如log.info(“模拟支付成功，订单号：{}”, orderNumber)），便于问题排查时区分 “模拟” 和 “真实” 流程。</p><p>五、改造总结<br>本次改造是 <strong>“最小侵入式”</strong> 的典范 —— 仅修改 3 类文件，新增 1 个开关，不破坏原有业务逻辑，实现了：</p><p>开发效率提升：无需配置微信 sandbox 环境，1 分钟完成支付 &#x2F; 退款测试；<br>演示灵活性：对外演示时，无需真实支付，直接展示全流程；<br>生产安全性：mock 与真实流程隔离，生产环境一键切回，无风险。<br>若后续需要扩展（如支持支付宝 mock），可参考此思路，在对应工具类中添加开关分支，保持设计一致性。<br>————————————————<br>版权声明：本文为CSDN博主「NEFUyellow386」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/2401_87905604/article/details/150648202">https://blog.csdn.net/2401_87905604/article/details/150648202</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>spring boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>spring boot</tag>
      
      <tag>mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务学习笔记</title>
    <link href="/2025/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Nacos配置核心要点"><a href="#Nacos配置核心要点" class="headerlink" title="Nacos配置核心要点"></a>Nacos配置核心要点</h2><h3 id="1-配置文件设置"><a href="#1-配置文件设置" class="headerlink" title="1. 配置文件设置"></a>1. 配置文件设置</h3><ul><li>使用<a href="file:///Users/binyellow/java-study/hmall/pay-service/target/classes/bootstrap.yaml">bootstrap.yaml</a>而不是<a href="file:///Users/binyellow/java-study/hmall/pay-service/target/classes/application.yaml">application.yaml</a>来配置Nacos注册中心参数</li><li>必须包含以下基本配置项：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">服务名称</span> <span class="hljs-comment"># 如user-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">Nacos服务器地址</span> <span class="hljs-comment"># 如127.0.0.1:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">命名空间ID</span> <span class="hljs-comment"># 可选</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-依赖配置"><a href="#2-依赖配置" class="headerlink" title="2. 依赖配置"></a>2. 依赖配置</h3><p>主要需要以下依赖：</p><ul><li><code>spring-cloud-starter-alibaba-nacos-discovery</code> - Nacos服务发现</li><li><code>spring-cloud-starter-openfeign</code> - Feign客户端（如需服务间调用）</li><li><code>spring-cloud-starter-loadbalancer</code> - 负载均衡（配合Feign使用）</li></ul><h3 id="3-主应用类注解"><a href="#3-主应用类注解" class="headerlink" title="3. 主应用类注解"></a>3. 主应用类注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 启用服务发现</span><br><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span> <span class="hljs-comment">// 如使用Feign</span><br></code></pre></td></tr></table></figure><h3 id="4-常见问题及解决方案"><a href="#4-常见问题及解决方案" class="headerlink" title="4. 常见问题及解决方案"></a>4. 常见问题及解决方案</h3><h4 id="服务无法注册问题"><a href="#服务无法注册问题" class="headerlink" title="服务无法注册问题"></a>服务无法注册问题</h4><ul><li>检查是否缺少bootstrap.yaml文件</li><li>确认主应用类是否添加了@EnableDiscoveryClient注解</li><li>检查Nacos服务地址配置是否正确</li></ul><h4 id="Feign客户端问题"><a href="#Feign客户端问题" class="headerlink" title="Feign客户端问题"></a>Feign客户端问题</h4><ul><li>确保添加了spring-cloud-starter-openfeign依赖</li><li>正确配置@EnableFeignClients注解</li><li>不要手动配置Feign的customizers，让Spring Cloud自动配置</li></ul><h4 id="负载均衡问题"><a href="#负载均衡问题" class="headerlink" title="负载均衡问题"></a>负载均衡问题</h4><ul><li>添加spring-cloud-starter-loadbalancer依赖</li><li>确保服务间调用使用服务名而不是硬编码地址</li></ul><h3 id="5-多服务一致性"><a href="#5-多服务一致性" class="headerlink" title="5. 多服务一致性"></a>5. 多服务一致性</h3><p>在我们的hmall项目中，user-service、trade-service、pay-service等都需要相同的Nacos配置模式才能正常工作。</p><p>以上就是我们处理Nacos配置过程中的关键知识点，这些都是保证微服务能够正常注册和发现的重要配置要素。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>spring cloud alibaba</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>usage</title>
    <link href="/2025/11/28/usage/"/>
    <url>/2025/11/28/usage/</url>
    
    <content type="html"><![CDATA[<p>这份 <strong>“Hexo 博客管理速查手册”</strong> 是专门为你准备的。你可以把它保存到笔记软件里，以后忘记指令了就看一眼。</p><p>这里包含了<strong>写文章</strong>、<strong>搞分类</strong>、<strong>发布更新</strong>以及<strong>Fluid 主题特有设置</strong>的完整流程。</p><hr><h3 id="一、-日常写作三部曲-最常用"><a href="#一、-日常写作三部曲-最常用" class="headerlink" title="一、 日常写作三部曲 (最常用)"></a>一、 日常写作三部曲 (最常用)</h3><p>这是你以后每次写博客都会重复的流程。</p><h4 id="1-创建新文章"><a href="#1-创建新文章" class="headerlink" title="1. 创建新文章"></a>1. 创建新文章</h4><p>打开终端，进入博客根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;文章标题&quot;</span><br><span class="hljs-comment"># 例子：hexo new &quot;Docker学习笔记&quot;</span><br></code></pre></td></tr></table></figure><ul><li>系统会提示你文件生成在 <code>source/_posts/Docker学习笔记.md</code>。</li><li>用 VS Code 或记事本打开这个文件开始写作。</li></ul><h4 id="2-必须掌握的头部写法-Front-matter"><a href="#2-必须掌握的头部写法-Front-matter" class="headerlink" title="2. 必须掌握的头部写法 (Front-matter)"></a>2. 必须掌握的头部写法 (Front-matter)</h4><p>在文章的最顶部，决定了文章的分类和标签。<strong>注意冒号后必须有空格！</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: Docker学习笔记<br>date: 2025-11-28 20:30:00<br>tags: <br><span class="hljs-bullet">  -</span> Docker<br><span class="hljs-bullet">  -</span> 运维<br>categories: <br><span class="hljs-bullet">  -</span> 后端技术<br><span class="hljs-section">  - 容器化</span><br><span class="hljs-section">---</span><br>这里开始写正文...<br></code></pre></td></tr></table></figure><ul><li>**tags (标签)**：像关键词，一篇文章可以有多个（比如：Java, 笔记）。</li><li>**categories (分类)**：像文件夹，支持多级（比如：后端技术 -&gt; Java）。</li></ul><h4 id="3-本地预览"><a href="#3-本地预览" class="headerlink" title="3. 本地预览"></a>3. 本地预览</h4><p>写完后，先在本地看看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><p>打开 <code>localhost:4000</code> 检查无误后，按 <code>Ctrl + C</code> 停止服务。</p><hr><h3 id="二、-发布与更新-上传到-GitHub"><a href="#二、-发布与更新-上传到-GitHub" class="headerlink" title="二、 发布与更新 (上传到 GitHub)"></a>二、 发布与更新 (上传到 GitHub)</h3><p>无论是<strong>发布新文章</strong>，还是<strong>修改了错别字</strong>，或者是<strong>改了主题配置</strong>，统一都用这套“三连击”指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 清理旧缓存 (防止页面没变、样式错乱)</span><br>hexo clean<br><br><span class="hljs-comment"># 2. 生成静态网页 (把 Markdown 变成 HTML)</span><br>hexo g<br><br><span class="hljs-comment"># 3. 推送到 GitHub (Go Live!)</span><br>hexo d<br></code></pre></td></tr></table></figure><p>💡 <strong>偷懒技巧</strong>：你可以把这三行合并成一行运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><hr><h3 id="三、-开启“分类”和“标签”页面-Fluid-主题必做"><a href="#三、-开启“分类”和“标签”页面-Fluid-主题必做" class="headerlink" title="三、 开启“分类”和“标签”页面 (Fluid 主题必做)"></a>三、 开启“分类”和“标签”页面 (Fluid 主题必做)</h3><p>在 Fluid 主题中，菜单栏上的“分类”和“标签”按钮，<strong>默认点击是 404 的</strong>。你需要手动创建这两个特殊的页面（<strong>只需要做一次</strong>）。</p><h4 id="1-开启“分类”页"><a href="#1-开启“分类”页" class="headerlink" title="1. 开启“分类”页"></a>1. 开启“分类”页</h4><p>在终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page categories<br></code></pre></td></tr></table></figure><p>然后去编辑生成的文件 <code>source/categories/index.md</code>，把内容改成：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 分类<br>date: 2025-11-28 20:00:00<br>type: categories  &lt;-- 这一行最关键，告诉主题这是分类页<br><span class="hljs-section">layout: categories</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p><em>(注意：正文留空即可，不要写东西)</em></p><h4 id="2-开启“标签”页"><a href="#2-开启“标签”页" class="headerlink" title="2. 开启“标签”页"></a>2. 开启“标签”页</h4><p>在终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page tags<br></code></pre></td></tr></table></figure><p>去编辑 <code>source/tags/index.md</code>，改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 标签<br>date: 2025-11-28 20:00:00<br>type: tags       &lt;-- 这一行最关键<br><span class="hljs-section">layout: tags</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p>做完这两步后，运行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>，点击菜单栏的按钮，就能自动把你所有文章的分类和标签汇总展示出来了。</p><hr><h3 id="四、-常用指令速查表"><a href="#四、-常用指令速查表" class="headerlink" title="四、 常用指令速查表"></a>四、 常用指令速查表</h3><table><thead><tr><th align="left">简写指令</th><th align="left">完整指令</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><code>hexo n &quot;...&quot;</code></td><td align="left"><code>hexo new &quot;...&quot;</code></td><td align="left"><strong>新建文章</strong></td><td align="left">生成在 <code>source/_posts</code></td></tr><tr><td align="left"><code>hexo s</code></td><td align="left"><code>hexo server</code></td><td align="left"><strong>启动本地预览</strong></td><td align="left">访问 <code>localhost:4000</code></td></tr><tr><td align="left"><code>hexo g</code></td><td align="left"><code>hexo generate</code></td><td align="left"><strong>生成网页</strong></td><td align="left">编译 Markdown 为 HTML</td></tr><tr><td align="left"><code>hexo d</code></td><td align="left"><code>hexo deploy</code></td><td align="left"><strong>部署&#x2F;发布</strong></td><td align="left">推送到 GitHub</td></tr><tr><td align="left"><code>hexo clean</code></td><td align="left"><code>hexo clean</code></td><td align="left"><strong>清理缓存</strong></td><td align="left"><strong>遇到玄学问题先执行它</strong></td></tr><tr><td align="left"><code>hexo new page &quot;...&quot;</code></td><td align="left"><code>hexo new page &quot;...&quot;</code></td><td align="left"><strong>新建独立页面</strong></td><td align="left">如“关于我”、“友情链接”</td></tr></tbody></table><h3 id="五、-如果我想换电脑写博客怎么办？"><a href="#五、-如果我想换电脑写博客怎么办？" class="headerlink" title="五、 如果我想换电脑写博客怎么办？"></a>五、 如果我想换电脑写博客怎么办？</h3><p>这是很多新手容易踩的坑。<strong>GitHub 仓库 (<code>yellow386.github.io</code>) 里存的只是生成的网页 (HTML)，不是你的源代码 (Markdown)！</strong></p><p>为了防止电脑坏了导致博客源码丢失，建议你做最后一件重要的事：</p><ol><li>在 GitHub 上新建一个仓库，叫 <code>hexo-blog-source</code> (名字随意，设为 Private 私有仓库最好)。</li><li>把你的 <code>s</code> 文件夹整个上传到这个新仓库里备份。</li><li>以后每次写完，除了 <code>hexo d</code> 发布网页外，记得也要把源码 <code>git push</code> 到这个私有仓库备份。</li></ol><p>现在，你的博客技能树已经点满了！去写下你的第一篇技术总结吧！🚀</p>]]></content>
    
    
    <categories>
      
      <category>Guide</category>
      
    </categories>
    
    
    <tags>
      
      <tag>how to use io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2025/11/28/my-first-blog/"/>
    <url>/2025/11/28/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>以此来纪念我创作的第一篇博客！<br>(建议把这句话写在正文里，而不是作为标签)</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Start Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
